# `RUQT.f90` - Documentation

## Overview

The `RUQT.f90` file contains the main program `RUQT` (presumably an acronym for **R**eal-space **U**nabridged **Q**uantum **T**ransport or similar). This program is designed to perform quantum transport calculations, specifically calculating electrical current or transmission probability through a molecular or nanoscale system sandwiched between electrodes. It supports various levels of theory for describing the system's electronic structure, including Hartree-Fock (HF), Density Functional Theory (DFT), Configuration Interaction Singles and Doubles (CISD), and methods based on 2-particle Reduced Density Matrices (p2-RDM). The program can interface with data from several quantum chemistry packages like QChem, GAMESS, PySCF, Molcas, and Maple.

## Key Components

The primary component is the main program `RUQT`. Additionally, several subroutines and functions are defined directly within this file, some of which appear to be implementations or specialized versions of procedures declared in the `InterfaceMod` or `FunctionMod` modules.

### `RUQT` (Main Program)
*   **Description:** This is the main executable program. It orchestrates the entire quantum transport calculation.
    The typical workflow is as follows:
    1.  **Initialization:** Sets initial flags and timers.
    2.  **Read Input:** Calls `Get_Command_Argument` to get the input file name and then `ReadInput` (defined within `RUQT.f90`) to parse simulation parameters.
    3.  **Set Flags:** Calls `Flag_set` (defined within `RUQT.f90`) to determine the quantum chemistry package and theoretical method being used.
    4.  **Get Hartree-Fock/DFT Data:** Based on the flags, it calls one of the `Get_HF_...` subroutines (e.g., `Get_HF_QChem`, `Get_HF_GAMESS`, all defined within `RUQT.f90`) to read Hamiltonian (`H_Two`) and overlap (`Smat`) matrices, and potentially other data like MO coefficients and energies from files generated by external quantum chemistry packages.
    5.  **Electrode and System Partitioning:**
        *   If `ElectrodeType` is "Metal_WBL" (Metal Wide-Band Limit):
            *   Calls `PartitionHS_MetalWBL` (from `InterfaceMod`) to partition the system Hamiltonian and overlap matrices into electrode and device regions.
            *   Calls `Electrodes_MetalWBL` (from `InterfaceMod`) to compute the self-energy matrices (`Sigma_l`, `Sigma_r`) for the electrodes.
            *   Calculates broadening matrices (`Gamma_L`, `Gamma_R`) from the self-energies.
        *   If `ElectrodeType` is "Molecule_WBL" (Molecule Wide-Band Limit):
            *   Calls `Calculate_Coupling_MoleculeWBL` (from `InterfaceMod`) to get coupling strengths.
            *   Calls `Electrodes_MoleculeWBL` (from `InterfaceMod`) to compute self-energies.
            *   Calculates broadening matrices.
    6.  **Perform Calculation:** Based on `CalcType`:
        *   **Current Calculation:**
            *   Iterates over a range of bias voltages.
            *   For each voltage, iterates over a range of energies.
            *   Calculates the retarded Green's function (`gfc_r`) and advanced Green's function (`gfc_a`).
                *   For HF/DFT methods (`hf_flag` or `dft_flag` is true): `gfc_r` is computed directly using `gfc_r = inv(energy*Smat_cen - H_Two_cen - Sigma_l - Sigma_r)`.
                *   For correlated methods (`cisd_flag` or `rdm_flag` is true): `gfc_r` is computed by calling `Build_G_SD_Invert` (from `InterfaceMod`).
            *   Calculates the transmission for the current energy point using the Landauer formula: `transm(k) = Trace(Gamma_L * gfc_r * Gamma_R * gfc_a)`.
            *   Integrates the transmission over energy (weighted by Fermi function differences) to get the current for the current voltage.
        *   **Transmission Calculation:**
            *   Iterates over a range of energies.
            *   Calculates `gfc_r` and `gfc_a` as above.
            *   Calculates transmission `transm(k) = Trace(Gamma_L * gfc_r * Gamma_R * gfc_a)`.
    7.  **Write Output:** Writes the calculated current-voltage (I-V) curve or transmission spectrum to a `.dat` file named after the input file.
    8.  **Timing:** Reports the total CPU time for the calculation.
*   **Type:** Program
*   **Key Arguments/Parameters:** Takes one command-line argument: the path to the main input file.
*   **Return Value/Outputs:** Writes calculation results (I-V curve or transmission spectrum) to an output file. Prints progress and summary information to standard output.

### Subroutines/Functions Defined within `RUQT.f90`

*   **`adjoint(A, norb)`**
    *   **Description:** Calculates the adjoint (conjugate transpose) of a complex square matrix `A`.
    *   **Type:** Function
    *   **Key Arguments/Parameters:** `A` (input complex matrix), `norb` (input integer, dimension of the matrix).
    *   **Return Value/Outputs:** Complex matrix, the adjoint of `A`. (Note: Appears similar to `adjoint` in `FunctionMod`).
*   **`Get_HF_QChem(inputfile, norb, H_two, Smat)`**
    *   **Description:** Reads Hartree-Fock Hamiltonian (`H_two`) and overlap (`Smat`) matrices from QChem output files.
    *   **Type:** Subroutine
    *   **Key Arguments/Parameters:** `inputfile` (input string), `norb` (input integer), `H_two`, `Smat` (output real matrices). (Note: Appears similar to `Get_HF_QChem` in `InterfaceMod`).
*   **`Get_HF_Molcas(inputfile, norb, H_two, Smat)`**
    *   **Description:** Reads Fock matrix (`H_two`) and overlap (`Smat`) from Molcas output files ("FOCK_AO", "Overlap").
    *   **Type:** Subroutine
    *   **Key Arguments/Parameters:** `inputfile` (input string), `norb` (input integer), `H_two`, `Smat` (output real matrices). (Note: Appears similar to `Get_HF_Molcas` in `InterfaceMod`).
*   **`Get_HF_GAMESS(inputfile, numatomic, H_two, Smat, norb)`**
    *   **Description:** Reads HF Hamiltonian and overlap matrices from GAMESS output files. It can also read and subtract ECP (Effective Core Potential) contributions if ECP data is present.
    *   **Type:** Subroutine
    *   **Key Arguments/Parameters:** `inputfile` (input string), `numatomic`, `norb` (input integers), `H_two`, `Smat` (output real matrices). (Note: Appears similar to `Get_HF_GAMESS` in `InterfaceMod`).
*   **`Get_HF_PySCF(inputfile, numatomic, H_two, Smat, norb)`**
    *   **Description:** Reads Fock and overlap matrices from a PySCF output file (`.scf_dat`).
    *   **Type:** Subroutine
    *   **Key Arguments/Parameters:** `inputfile` (input string), `numatomic`, `norb` (input integers), `H_two`, `Smat` (output real matrices). (Note: Appears similar to `Get_HF_PySCF` in `InterfaceMod`).
*   **`Get_HF_libint(inputfile, norb, numact, H_one, Smat, mo_coeff, OneInts, TwoIntsCompact)`**
    *   **Description:** Reads one-electron Hamiltonian (`H_one`), overlap (`Smat`), MO coefficients, and one- and two-electron integrals from files presumably generated by a libint-based program.
    *   **Type:** Subroutine
    *   **Key Arguments/Parameters:** `inputfile` (input string), `norb`, `numact` (input integers), various matrices/arrays for integrals and coefficients (output). (Note: Appears similar to `Get_HF_libint` in `InterfaceMod`).
*   **`IntTransform(TwoIntsCompact, mo_coeff)`**
    *   **Description:** Placeholder for an integral transformation routine. Currently empty.
    *   **Type:** Subroutine
*   **`Calculate_Coupling_MoleculeWBL(Coupling_R, Coupling_L, localden_fermi)`**
    *   **Description:** Sets fixed coupling strengths for molecule-electrode interaction in the WBL. (Note: Simpler version compared to what might be expected; `localden_fermi` is unused).
    *   **Type:** Subroutine
    *   **Key Arguments/Parameters:** `Coupling_R`, `Coupling_L` (output reals), `localden_fermi` (input real, unused). (Note: Appears similar to `Calculate_Coupling_MoleculeWBL` in `InterfaceMod`).
*   **`Electrodes_MoleculeWBL(...)`**
    *   **Description:** Calculates self-energies for molecule WBL case. (Note: Arguments differ slightly from the interface version, and it's defined here directly).
    *   **Type:** Subroutine
*   **`Electrodes_MetalWBL(...)`**
    *   **Description:** Implementation for calculating metal electrode self-energies. (Note: Appears similar to `Electrodes_MetalWBL` in `InterfaceMod`, defined here directly).
    *   **Type:** Subroutine
*   **`PartitionHS_MetalWBL(...)`**
    *   **Description:** Implementation for partitioning Hamiltonian and overlap matrices for metal WBL. (Note: Appears similar to `PartitionHS_MetalWBL` in `InterfaceMod`, defined here directly).
    *   **Type:** Subroutine
*   **`fermi_function(energy, fermi_energy, KT)`**
    *   **Description:** Calculates the Fermi-Dirac distribution value.
    *   **Type:** Function
    *   **Key Arguments/Parameters:** `energy`, `fermi_energy`, `KT` (input reals).
    *   **Return Value/Outputs:** Real value of the Fermi function. (Note: Appears identical to `fermi_function` in `FunctionMod`).
*   **`inv(A)` / `inv_real(A)`**
    *   **Description:** Inverts a complex (`inv`) or real (`inv_real`) square matrix using LAPACK routines (`ZGETRF`/`ZGETRI` and `DGETRF`/`DGETRI`).
    *   **Type:** Function
    *   **Key Arguments/Parameters:** `A` (input matrix).
    *   **Return Value/Outputs:** The inverted matrix. (Note: Appears identical to `inv`/`inv_real` in `FunctionMod`).
*   **`FirstIndex(i, k)` / `CompositeIndex(ik, jl)`**
    *   **Description:** Functions for calculating packed indices for two-electron integrals.
    *   **Type:** Function
    *   **Key Arguments/Parameters:** Integer orbital indices.
    *   **Return Value/Outputs:** Packed integer index. (Note: Appears identical to those in `FunctionMod`).
*   **`matmul_zgemm(leftmatrix, rightmatrix)` / `matmul_dgemm(leftmatrix, rightmatrix)`**
    *   **Description:** Performs matrix multiplication for complex (`zgemm`) or real (`dgemm`) matrices using BLAS routines (`ZGEMM`/`DGEMM`).
    *   **Type:** Function
    *   **Key Arguments/Parameters:** `leftmatrix`, `rightmatrix` (input matrices).
    *   **Return Value/Outputs:** The product matrix. (Note: Appears identical to those in `FunctionMod`).
*   **`matmul_dgemm2(leftmatrix, rightmatrix, outmat)`**
    *   **Description:** Performs matrix multiplication for real matrices, storing the result in `outmat`.
    *   **Type:** Subroutine
    *   **Key Arguments/Parameters:** `leftmatrix`, `rightmatrix` (input), `outmat` (output). (Note: Appears identical to `matmul_dgemm2` in `FunctionMod`).
*   **`ReadInput(...)`**
    *   **Description:** Reads various simulation parameters from the specified input file.
    *   **Type:** Subroutine
    *   **Key Arguments/Parameters:** `inputfile` (input string), many output variables for simulation parameters. (Note: Appears similar to `ReadInput` in `InterfaceMod`).
*   **`Flag_set(...)`**
    *   **Description:** Sets logical flags based on input strings defining the calculation method and quantum chemistry package.
    *   **Type:** Subroutine
    *   **Key Arguments/Parameters:** `inputcode`, `functional` (input strings), various logical flags (output). (Note: Appears similar to `Flag_set` in `InterfaceMod`).

## Important Variables/Constants

*   **`inputfile`** (`character(len=100)`): Name of the main input file provided as a command-line argument. It's also used as a base name for other potential input/output files (e.g., `trim(inputfile) // "_Smat"`).
*   **`ElectrodeType`** (`character(len=40)`): Specifies the type of electrode model used, e.g., "Metal_WBL" or "Molecule_WBL". Read from the input file.
*   **`CalcType`** (`character(len=40)`): Specifies the type of calculation to perform, e.g., "current" or "Transmission". Read from the input file.
*   **`H_Two`** (`real(8), allocatable, dimension(:,:)`): Stores the core Hamiltonian or Fock matrix in the atomic orbital (AO) basis. For "Metal_WBL", this is partitioned into `H_Two_cen`, `H_Two_le`, `H_Two_re`.
*   **`Smat`** (`real(8), allocatable, dimension(:,:)`): Stores the overlap matrix in the AO basis. For "Metal_WBL", this is partitioned into `Smat_cen`, `Smat_le`, `Smat_re`.
*   **`Sigma_l`, `Sigma_r`** (`complex(8), allocatable, dimension(:,:)`): Left and right self-energy matrices representing the effect of the electrodes.
*   **`Gamma_L`, `Gamma_R`** (`complex(8), allocatable, dimension(:,:)`): Broadening matrices (coupling matrices) derived from the imaginary parts of the self-energies. `Gamma_L = i(Sigma_L - Sigma_L^dagger)`, `Gamma_R = i(Sigma_R - Sigma_R^dagger)`.
*   **`gfc_r`, `gfc_a`** (`complex(8), allocatable, dimension(:,:)`): Retarded and advanced Green's function matrices for the central device region.
*   **`transm`** (`real(8), allocatable, dimension(:)`): Array storing the calculated transmission probability at each energy point.
*   **`current`** (`real(8), allocatable, dimension(:)`): Array storing the calculated current at each voltage point.
*   **`energy_start`, `energy_end`, `delta_en`** (`real(8)`): Define the energy window and step for transmission/current calculations.
*   **`volt_start`, `volt_end`, `delta_volt`** (`real(8)`): Define the voltage window and step for current calculations.
*   **`KT`** (`real(8)`): Thermal energy (k_B * T).
*   **`qchem`, `gamess`, `pyscf`, `maple`, `molcas`** (`logical`): Flags indicating the source of quantum chemistry data.
*   **`hf_flag`, `dft_flag`, `cisd_flag`, `rdm_flag`** (`logical`): Flags indicating the level of theory.
*   **`doubles`** (`logical`): Flag indicating if double excitations are included (relevant for `cisd_flag` or `rdm_flag` with `Build_G_SD_Invert`).
*   **`B1data`, `B2data`** (`type(B1)`, `type(B2)`): Derived type instances for storing one- and two-electron integral like quantities, used by `Build_G_SD_Invert`.

## Usage Examples

The program is executed from the command line, with the path to an input file as its argument.

```bash
./RUQT.x my_calculation_input.inp
```

Where `my_calculation_input.inp` is a text file containing the parameters read by the `ReadInput` subroutine. An example structure for `my_calculation_input.inp` would be:

```
Current                ! CalcType: "Current" or "Transmission"
Metal_WBL              ! Electrode_Type: "Metal_WBL" or "Molecule_WBL"
0.0                    ! Fermi_enl (Fermi energy left electrode)
0.0                    ! Fermi_enr (Fermi energy right electrode)
0.1                    ! localden_fermi_l (Density of states left)
0.1                    ! localden_fermi_r (Density of states right)
28                     ! norb (Total number of orbitals)
28                     ! numatomic (Number of atomic orbitals)
0                      ! numfcore (Number of frozen core orbitals)
0                      ! numfvirt (Number of frozen virtual orbitals)
14                     ! numocc (Number of occupied orbitals)
14                     ! numvirt (Number of virtual orbitals)
10                     ! size_c (Orbitals in device region)
9                      ! size_l (Orbitals in left electrode)
9                      ! size_r (Orbitals in right electrode)
-5.0                   ! energy_start (eV)
5.0                    ! energy_end (eV)
0.01                   ! delta_en (eV)
0.0                    ! volt_start (V)
1.0                    ! volt_end (V)
0.1                    ! delta_volt (V)
0.02585199            ! KT (Thermal energy, eV, e.g. room temp)
gamess                 ! inputcode (e.g., "qchem", "gamess", "pyscf", "maple")
true                   ! doubles (true for correlated methods like CISD/RDM with doubles)
rdm                    ! functional (e.g., "hf", "dft", "cisd", "rdm")
false                  ! use_b0 (whether to use B0 term in Build_G_SD_Invert)
cisd                   ! b0_type ("cisd" or "rdm")
```

The program will then generate an output file, for instance, `my_calculation_input.inp.dat`, containing the I-V curve or transmission spectrum.

## Dependencies and Interactions

*   **Internal Dependencies:**
    *   `InterfaceMod`: Used to access interfaces for subroutines like `PartitionHS_MetalWBL`, `Electrodes_MetalWBL`, `Calculate_Coupling_MoleculeWBL`, `Electrodes_MoleculeWBL`, and crucially `Build_G_SD_Invert`. However, many subroutines with identical or similar names/functionality are also defined directly within `RUQT.f90` (e.g., `ReadInput`, `Flag_set`, `Get_HF_...` routines, matrix functions). This suggests a potential for refactoring to consistently use the module versions.
    *   `FunctionMod`: Used to access interfaces for mathematical utility functions like `matmul_zgemm`, `adjoint`, `inv`, `fermi_function`. Again, many of these are also implemented directly in `RUQT.f90`.
    *   `TypeMod`: Used for derived types `B1`, `B2`, and `energr`, which are essential for passing data to and from `Build_G_SD_Invert` and for storing Green's function data.
*   **External Libraries:**
    *   **LAPACK/BLAS:** Indirectly used via functions like `inv`, `inv_real`, `matmul_zgemm`, `matmul_dgemm` (which call `ZGETRF`/`ZGETRI`, `DGETRF`/`DGETRI`, `ZGEMM`, `DGEMM` respectively). These libraries must be linked for the program to compile and run.
*   **Interactions with other components:**
    *   **Input File:** The program's behavior is heavily dictated by parameters read from an input file specified as a command-line argument.
    *   **Quantum Chemistry Package Outputs:** Reads data files generated by external packages (QChem, GAMESS, PySCF, Molcas, Maple) for Hamiltonian, overlap, and potentially MO coefficients/energies and T1/T2 amplitudes (for correlated methods via `Build_G_SD_Invert`). The file naming conventions are specific to each package (e.g., `inputfile_Smat`, `inputfile_Htwo` for QChem; `inputfile.T2`, `inputfile.mo_dat` for GAMESS when `Build_G_SD_Invert` is called).
    *   **Output File:** Generates a `.dat` file containing the primary results (I-V curve or transmission spectrum).
    *   **`Build_G_SD_Invert.f90`:** Interacts closely with this file (via `InterfaceMod`) when performing correlated calculations (`cisd_flag` or `rdm_flag` is true). `RUQT` passes necessary data like self-energies, energy, orbital information, and data from `B1data`/`B2data` types to `Build_G_SD_Invert`.
    *   **Subroutines within `RUQT.f90`:** The main program calls many subroutines defined within the same file. The presence of these local implementations alongside module-based interfaces suggests a mixed approach to code organization. For maintainability, it would be beneficial to consistently use module-provided routines where available and appropriate, or to move these local routines into relevant modules if they are of general utility.
```
